---
nav_title: 競合状態
article_title: 競合状態
alias: /race_conditions/
page_order: 9
page_type: reference
description: "この記事では、競合状態がメッセージングキャンペーンに影響を与えないようにするためのベストプラクティスを紹介します。"
toc_headers: h2
---

# 競合状態

> 競合状態は、結果が複数の事象の順序またはタイミングに依存する場合に発生します。例えば、「イベントA」→「イベントB」という順序が望ましいが、「イベントA」が先に来ることもあれば、「イベントB」が先に来ることもあります - これは競合状態として知られています。これらのイベントは、共有リソースやデータにアクセスするために競合するため、予期せぬ結果やエラーにつながる可能性があります。

{% multi_lang_include video.html id="LyJaxDoMtMs" align="right" %}

Braze では、ユーザーデータやイベントに基づいて複数のアクションが同時にトリガーされると、競合状態が発生する可能性があります。例えば、ユーザーが複数のキャンペーン (ニュースレターへの登録や購入など) をトリガーした場合、正しい順序でメッセージを受け取れない可能性があります。

## 競合状態のタイプ

最も一般的な競合状態は、以下のような場合に発生する可能性があります。

- 新規ユーザーをターゲットにする
- 複数の API エンドポイントを使用する
- アクションベースのトリガーとオーディエンスフィルターのマッチング 

以下のシナリオを検討し、これらの競合状態を回避するためのベストプラクティスを実施します。

## シナリオ1:新規ユーザーをターゲットにする

Braze で最も一般的な競合状態の1つは、新しく作成されたユーザーをターゲットとするメッセージで発生します。予想されるイベントの順序は次のとおりです。

1. ユーザーが作成される
2. 同じユーザーが即座にメッセージのターゲットとなり、カスタムイベントを実行するか、カスタム属性を記録する。

ただし、場合によっては、2 番目の事象が最初にトリガーすることもあります。これは、まだ存在しないユーザーにメッセージを送信しようとしていることを意味します。その結果、ユーザーがそれを受け取ることありません。イベントや属性が、まだ作成されていないユーザープロファイルに記録されようとしている場合も同様に当てはまります。

### ベストプラクティス

#### 遅延を導入する

新規ユーザーが作成された後、ターゲットキャンペーンやキャンバスを送信する前に遅延を追加することができます。このタイミング遅延により、ユーザープロファイルが作成され、メッセージ受信の適格性を決定する可能性のある関連属性が更新されます。

例えば、ユーザーがアプリに登録した後、24時間後にプロモーションオファーを送ることができます。あるいは、ユーザーを作成したり、カスタム属性をログに記録している場合は、この競合状態を避けるために、処理を進める前に1分間の遅延を加えることができます。

新しいユーザーがキャンバスにエントリするトリガーとなる特定のカスタムイベントに対して、[Braze SDK]({{site.baseurl}}/developer_guide/sdk_integration) でこの遅延を追加することもできます。 

## シナリオ2：複数の API エンドポイントを使用する

{% alert important %}
非同期処理を使用して、速度と柔軟性を最大化します。これは、APIコールが私たちに別々に送られた場合、それらが送られた順番で処理されることを保証できないことを意味します。
{% endalert %}

複数の API エンドポイントがこの競合状態を引き起こすシナリオもいくつかあります。以下のような場合です。

- 別々の API エンドポイントを使用してユーザーを作成し、キャンバスやキャンペーンをトリガーする
- カスタム属性、イベント、または購入を更新するために、`/users/track` エンドポイントに複数の個別の呼び出しを行う

ユーザー情報が [`/users/track` エンドポイント]({{site.baseurl}}/api/endpoints/user_data/post_user_track)を使用して Braze に送信される場合、処理に数秒かかることがあります。これは、`/users/track`と`/campaign/trigger/send`のようなメッセージングエンドポイントsに対して同時にリクエストが行われた場合、メッセージが送信されるまでにユーザーが更新dであることを保証するものではないことを意味する。

{% alert note %}
ユーザー 属性s とイベントが同じリクエスト(`/users/track` またはSDKから) で送信される場合、Braze は属性s を処理してからイベントを生成するか、またはメッセージを送信しようとします。
{% endalert %}

### ベストプラクティス

#### 複数のエンドポイントを使用する場合は、リクエストを1つずつ送信します。

複数のエンドポイントを使用している場合は、リクエストをずらして、次のリクエストが始まる前に各リクエストが完了するようにしてみるとよいです。これにより競合の可能性を減らすことができます。例えば、ユーザー属性を更新してメッセージを送信する必要がある場合、エンドポイントを使用してメッセージを送信する前に、まずユーザープロファイルが完全に更新されるのを待ちます。

スケジュールされたメッセージ API リクエストを送信する場合、これらのリクエストは別個のものでなければならず、スケジュールされた API リクエストを送信する前にユーザーを作成しなければなりません。

#### トリガーに主要データを含める

複数のエンドポイントを使用する代わりに、[`campaign/trigger/send` エンドポイント]({{site.baseurl}}/api/endpoints/messaging/send_messages/post_send_triggered_campaigns)を使用して、単一の API 呼び出しに[ユーザー属性]({{site.baseurl}}/api/objects_filters/user_attributes_object#object-body)と[トリガープロパティ]({{site.baseurl}}/api/objects_filters/trigger_properties_object)を含めることができます。 

これらのオブジェクトがトリガーに含まれている場合、メッセージがトリガーされる前に属性s が最初に処理され、潜在的な競合s が排除されます。トリガープロパティはユーザープロファイルを更新するのではなく、メッセージのコンテキストの中だけで使われることに注意してください。

#### POST を使用する：ユーザーをトラッキング(同期)するエンドポイント

この[`/users/track/sync/`エンドポイント]({{site.baseurl}}/api/endpoints/user_data/post_user_track_synchronous)を使用して、カスタムイベントと購入を記録し、ユーザープロファイル属性を同期的に更新します。このエンドポイントを使用して、1回の呼び出しでユーザープロファイルを同時に更新すると、競合状態の可能性を防ぐのに役立ちます。

{% alert important %}
このエンドポイントは現在ベータ版である。ベータ版への参加に興味がある場合は、Braze のアカウントマネージャーに連絡してください。
{% endalert %}

## シナリオ3：アクションベースのトリガーとオーディエンスフィルターのマッチング

アクションベースのキャンペーンまたはキャンバスを、オーディエンスフィルターと同じトリガー (変更された属性やカスタムイベントを実行した場合など) で構成した場合、別の一般的な競合状態が発生する可能性があります。ユーザーは、トリガーイベントを実行した時点ではオーディエンスにいない可能性があります。つまり、キャンペーンを受け取ることもキャンバスに入ることもありません。

### ベストプラクティス

#### 遅延後にオーディエンスをチェックする

トリガー条件を含むオーディエンスフィルターの使用を避けるため、配信前にオーディエンスをチェックすることをおすすめします。例えば、キャンバスメッセージステップで追加チェックとして[配信検証を使用して]({{site.baseurl}}/user_guide/engagement_tools/canvas/canvas_components/message_step/#edit-delivery-settings)メッセージ送信時にオーディエンスが配信基準を満たしていることを確認できます。また、キャンバスの終了条件を活用することで、ユーザージャーニー中のどの時点でも、条件を満たしたユーザーを終了させることができます。

キャンペーンでは、終了イベントを使用して、トリガーイベントのあるキャンペーンが遅延中に終了イベントを実行するユーザーへのメッセージを中止できるようにすることができます。

#### トリガーイベントでユニークなフィルターを使用する。

フィルターを構成するときに、「念のため」冗長フィルターを追加することをおすすめします。しかし、この冗長性はさらなる問題を引き起こす可能性ありますその代わり、可能な限りトリガーを含むフィルターの使用は避けます。これが競合状態を避けるための最も安全なルートです。

たとえば、キャンペーントリガーが「購入済み」で、オーディエンスフィルターが 「何らかの購入を行った」の場合、この冗長性によって競合状態が発生する可能性があります。 

#### トリガーイベントが更新されたと仮定するオーディエンスフィルターは避けます。

このベストプラクティスは、トリガーイベントで冗長なフィルターを回避することと似ています。通常、トリガー事象がユーザープロファイルに対して更新dであると仮定するフィルターは失敗する。

#### Liquid aborts を使用する (属性のみ）

キャンペーンおよびキャンバスのステップでは、エントリスケジュールでトリガー属性を含むオーディエンスフィルターの使用を避けるために、Liquid aborts を使用します。例えば、「好きな色」という配列属性があり、その属性配列を任意の値で更新し、更新完了後に配列に「青」という色が入っているユーザーをターゲットにしたいとします。この例でオーディエンスフィルターを使用すると、競合状態が発生し、配列に「青」を初めて追加したユーザーを見逃すことになります。

このケースでは、キャンペーンでトリガー遅延を実装するか、キャンバスで遅延ステップを使用し、一定期間ユーザープロファイルを更新できるようにしてから、次の Liquid abort ロジックを使用します。

{% raw %}
```liquid
{%assign colors={{custom_attribute.$(Favorite Color)|split:”,”}}%}
{%unless colors contains ‘Blue’%}
{%abort_message(Blue not present)%}
{%endunless%}
```
{% endraw %}

#### ユーザーデータの管理方法を確認する

キャンバスエントリの評価中に競合がある場合、ユーザーs は、入力しようとしていなかったキャンバスに入ることがあります。たとえば、ユーザーのプロファイルをオーディエンスに含めるように設定し、その後、キャンバスがユーザーs をオーディエンスで使用できなくなるようにエンキューした後にd を更新することができます。 

ユーザー トリガーが同じ秒内にキャンバスエントリイベントを複数回実行する場合、(再エントリが有効になっていても) Braze はその秒のエントリを1 つだけ許可します。これにより、エントリーの重複が防止されるため、キャンバスエントリーの総数がトリガーイベントの総数よりも少なくなる可能性があります。

ユーザーデータがどのように管理されているかを確認し、d を更新することをお勧めします。具体的には、SDK、API、一括処理API、および他のメソッドなどによって、属性 s が d に更新する時期と方法を確認します。これにより、ユーザーがキャンペーンまたはキャンバスに入った理由と、ユーザーのプロファイルが更新であった理由を特定し、明確にすることができます。
