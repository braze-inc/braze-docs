#!/usr/bin/env python3

# Uses 'git diff' to track renamed files or directories, then creates redirects 
# in 'assets/js/broken_redirect_list.js'. Note that redirects are only created 
# for renamed files if they're 'committed', not just 'added' to the branch.
#
# Usage: ./bdocs mredirects

import os
import re
import subprocess

# Global variables
PROJECT_ROOT = os.environ.get('PROJECT_ROOT')
REDIRECT_FILE = os.environ.get('REDIRECT_FILE')


# Uses Git to return a list of renamed files and directories in this format:
#   files:       rename _docs/_contributing/{bdocs.md => test.md} (100%)
#   directories: rename _docs/_contributing/{yaml => jekyll}/metadata.md (100%)
def get_renamed_files():
    cmd = f"git diff -M --summary develop HEAD -- {os.path.join(PROJECT_ROOT, '_docs')}"
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    changed_files = [line.strip() for line in result.stdout.splitlines() if line.startswith("rename") or line.startswith(" rename")]

    if not changed_files:
        print("Error: Git can't find any renamed files committed in this branch.\nNote that redirects are only created for renamed files if they're 'committed', not just 'added' to the branch.")
        return []
    
    return changed_files


# Creates redirects by cleaning up the list generated by 'get_renamed_files'.
def create_redirect(line):
     # Save original for debugging
    original_line = line.strip()

    # Remove 'rename ' and percentage '(98%)'. For example:
    #   before: rename _docs/_contributing/{yaml => jekyll}/metadata.md (100%)
    #   after:  _docs/_contributing/{yaml => jekyll}/metadata.md
    line = line.split(" ", 1)[1]
    line = re.sub(r"\s\(\d+%\)$", "", line)

    # Create group using '{}' then '=>' to split into subgroups. For example:
    #   regex_group:  {yaml => jekyll}
    #   subgroup_old: yaml
    #   subgroup_new: jekyll
    regex_group = re.search(r"{([^}]+) => ([^}]+)}", line)
    subgroup_old = regex_group.group(1)
    subgroup_new = regex_group.group(2)
    
    # Get the relative path to renamed file or directory. For example:
    #   before: _docs/_contributing/{yaml => jekyll}/metadata.md
    #   after:  _docs/_contributing/
    path = line.split("{")[0].strip()

    # This will be empty if an individual file was renamed and not a directory.
    # If a directory, stores the filename within that directory. For example:
    #   before: _docs/_contributing/{yaml => jekyll}/metadata.md
    #   after:  metadata.md 
    renamed_dir_file = line.split("}")[1].strip()
    
    # Use previous variables to build old and new URLs. For example:
    #  old: /docs/contributing/yaml/metadata
    #  new: /docs/contributing/jekyll/metadata
    url_old = f"/{path}{subgroup_old}{renamed_dir_file}".replace("/_", "/").replace(".md", "")
    url_new = f"/{path}{subgroup_new}{renamed_dir_file}".replace("/_", "/").replace(".md", "")

    print("Redirects created successfully!")
    return f"validurls['{url_old}'] = '{url_new}';"


# Remove duplicate lines while preserving single blank lines
def remove_duplicates(lines):
    unique_lines = []
    double_blank = False

    for line in lines:
        if line.strip() == "":          
            if not double_blank:         
                unique_lines.append(line)
                double_blank = True
        else:                           
            double_blank = False
            if line not in unique_lines:
                unique_lines.append(line)

    return unique_lines


def main():
    changed_files = get_renamed_files()
    
    with open(REDIRECT_FILE, 'r+') as f:
        lines = f.readlines()

        # Remove any existing placeholder comment
        lines = [l for l in lines if l.strip() != "// validurls['OLD'] = 'NEW';"]

        # Append any new redirects
        for line in changed_files:
            redirect_line = create_redirect(line)
            if redirect_line:
                lines.append(redirect_line + "\n")

        # Re-add placeholder comment
        lines.append("\n// validurls['OLD'] = 'NEW';\n")

        # Remove duplicates
        unique_lines = remove_duplicates(lines)

        # Rewrite file
        f.seek(0)
        f.truncate()
        f.writelines(unique_lines)


if __name__ == "__main__":
    main()
